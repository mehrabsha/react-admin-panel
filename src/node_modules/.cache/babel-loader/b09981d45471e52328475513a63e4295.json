{"ast":null,"code":"import { ToRawFixed } from './ToRawFixed';\nimport { digitMapping } from './digit-mapping.generated';\nimport { S_UNICODE_REGEX } from '../regex.generated'; // This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\n\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\" + S_UNICODE_REGEX.source); // /\\p{S}$/u\n\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(S_UNICODE_REGEX.source + \"$\");\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n  var sign = numberResult.sign,\n      exponent = numberResult.exponent,\n      magnitude = numberResult.magnitude;\n  var notation = options.notation,\n      style = options.style,\n      numberingSystem = options.numberingSystem;\n  var defaultNumberingSystem = data.numbers.nu[0]; // #region Part 1: partition and interpolate the CLDR number pattern.\n  // ----------------------------------------------------------\n\n  var compactNumberPattern = null;\n\n  if (notation === 'compact' && magnitude) {\n    compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n  } // This is used multiple times\n\n\n  var nonNameCurrencyPart;\n\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var byCurrencyDisplay = data.currencies[options.currency];\n\n    if (byCurrencyDisplay) {\n      switch (options.currencyDisplay) {\n        case 'code':\n          nonNameCurrencyPart = options.currency;\n          break;\n\n        case 'symbol':\n          nonNameCurrencyPart = byCurrencyDisplay.symbol;\n          break;\n\n        default:\n          nonNameCurrencyPart = byCurrencyDisplay.narrow;\n          break;\n      }\n    } else {\n      // Fallback for unknown currency\n      nonNameCurrencyPart = options.currency;\n    }\n  }\n\n  var numberPattern;\n\n  if (!compactNumberPattern) {\n    // Note: if the style is unit, or is currency and the currency display is name,\n    // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n    if (style === 'decimal' || style === 'unit' || style === 'currency' && options.currencyDisplay === 'name') {\n      // Shortcut for decimal\n      var decimalData = data.numbers.decimal[numberingSystem] || data.numbers.decimal[defaultNumberingSystem];\n      numberPattern = getPatternForSign(decimalData.standard, sign);\n    } else if (style === 'currency') {\n      var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]; // We replace number pattern part with `0` for easier postprocessing.\n\n      numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n    } else {\n      // percent\n      var percentPattern = data.numbers.percent[numberingSystem] || data.numbers.percent[defaultNumberingSystem];\n      numberPattern = getPatternForSign(percentPattern, sign);\n    }\n  } else {\n    numberPattern = compactNumberPattern;\n  } // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n  // used to infer decimal group sizes.\n\n\n  var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0]; // Now we start to substitute patterns\n  // 1. replace strings like `0` and `#,##0.00` with `{0}`\n  // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n\n  numberPattern = numberPattern.replace(CLDR_NUMBER_PATTERN, '{0}').replace(/'(.)'/g, '$1'); // Handle currency spacing (both compact and non-compact).\n\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]; // See `currencySpacing` substitution rule in TR-35.\n    // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n    //\n    // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n    // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n    // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n    //\n    // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n    // and number, because `$` does not match \"[:^S:]\".\n    //\n    // Implementation note: here we do the best effort to infer the insertion.\n    // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n\n    var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n\n    if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\" + afterCurrency + \"{0}\");\n    }\n\n    var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n\n    if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('{0}¤', \"{0}\" + beforeCurrency + \"\\u00A4\");\n    }\n  } // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n\n\n  var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n  var numberParts = [];\n  var symbols = data.numbers.symbols[numberingSystem] || data.numbers.symbols[defaultNumberingSystem];\n\n  for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n    var part = numberPatternParts_1[_i];\n\n    if (!part) {\n      continue;\n    }\n\n    switch (part) {\n      case '{0}':\n        {\n          // We only need to handle scientific and engineering notation here.\n          numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, // If compact number pattern exists, do not insert group separators.\n          !compactNumberPattern && options.useGrouping, decimalNumberPattern));\n          break;\n        }\n\n      case '-':\n        numberParts.push({\n          type: 'minusSign',\n          value: symbols.minusSign\n        });\n        break;\n\n      case '+':\n        numberParts.push({\n          type: 'plusSign',\n          value: symbols.plusSign\n        });\n        break;\n\n      case '%':\n        numberParts.push({\n          type: 'percentSign',\n          value: symbols.percentSign\n        });\n        break;\n\n      case '¤':\n        // Computed above when handling currency spacing.\n        numberParts.push({\n          type: 'currency',\n          value: nonNameCurrencyPart\n        });\n        break;\n\n      default:\n        if (/^\\{c:/.test(part)) {\n          numberParts.push({\n            type: 'compact',\n            value: part.substring(3, part.length - 1)\n          });\n        } else {\n          // literal\n          numberParts.push({\n            type: 'literal',\n            value: part\n          });\n        }\n\n        break;\n    }\n  } // #endregion\n  // #region Part 2: interpolate unit pattern if necessary.\n  // ----------------------------------------------\n\n\n  switch (style) {\n    case 'currency':\n      {\n        // `currencyDisplay: 'name'` has similar pattern handling as units.\n        if (options.currencyDisplay === 'name') {\n          var unitPattern = (data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]).unitPattern; // Select plural\n\n          var unitName = void 0;\n          var currencyNameData = data.currencies[options.currency];\n\n          if (currencyNameData) {\n            unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n          } else {\n            // Fallback for unknown currency\n            unitName = options.currency;\n          } // Do {0} and {1} substitution\n\n\n          var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n          var result = [];\n\n          for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n            var part = unitPatternParts_1[_a];\n\n            switch (part) {\n              case '{0}':\n                result.push.apply(result, numberParts);\n                break;\n\n              case '{1}':\n                result.push({\n                  type: 'currency',\n                  value: unitName\n                });\n                break;\n\n              default:\n                if (part) {\n                  result.push({\n                    type: 'literal',\n                    value: part\n                  });\n                }\n\n                break;\n            }\n          }\n\n          return result;\n        } else {\n          return numberParts;\n        }\n      }\n\n    case 'unit':\n      {\n        var unit = options.unit,\n            unitDisplay = options.unitDisplay;\n        var unitData = data.units.simple[unit];\n        var unitPattern = void 0;\n\n        if (unitData) {\n          // Simple unit pattern\n          unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n        } else {\n          // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n          // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n          // Implementation note: we are not following TR-35 here because we need to format to parts!\n          var _b = unit.split('-per-'),\n              numeratorUnit = _b[0],\n              denominatorUnit = _b[1];\n\n          unitData = data.units.simple[numeratorUnit];\n          var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n          var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n\n          if (perUnitPattern) {\n            // perUnitPattern exists, combine it with numeratorUnitPattern\n            unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n          } else {\n            // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n            // the denominator pattern in singular form.\n            var perPattern = data.units.compound.per[unitDisplay];\n            var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n            unitPattern = unitPattern = perPattern.replace('{0}', numeratorUnitPattern).replace('{1}', denominatorPattern.replace('{0}', ''));\n          }\n        }\n\n        var result = []; // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n\n        for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n          var part = _d[_c];\n          var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n\n          if (interpolateMatch) {\n            // Space before \"{0}\"\n            if (interpolateMatch[1]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[1]\n              });\n            } // \"{0}\" itself\n\n\n            result.push.apply(result, numberParts); // Space after \"{0}\"\n\n            if (interpolateMatch[2]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[2]\n              });\n            }\n          } else if (part) {\n            result.push({\n              type: 'unit',\n              value: part\n            });\n          }\n        }\n\n        return result;\n      }\n\n    default:\n      return numberParts;\n  } // #endregion\n\n} // A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\n\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping,\n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n  var result = []; // eslint-disable-next-line prefer-const\n\n  var n = numberResult.formattedString,\n      x = numberResult.roundedNumber;\n\n  if (isNaN(x)) {\n    return [{\n      type: 'nan',\n      value: n\n    }];\n  } else if (!isFinite(x)) {\n    return [{\n      type: 'infinity',\n      value: n\n    }];\n  }\n\n  var digitReplacementTable = digitMapping[numberingSystem];\n\n  if (digitReplacementTable) {\n    n = n.replace(/\\d/g, function (digit) {\n      return digitReplacementTable[+digit] || digit;\n    });\n  } // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n  // representation of n in the given numbering system.\n\n\n  var decimalSepIndex = n.indexOf('.');\n  var integer;\n  var fraction;\n\n  if (decimalSepIndex > 0) {\n    integer = n.slice(0, decimalSepIndex);\n    fraction = n.slice(decimalSepIndex + 1);\n  } else {\n    integer = n;\n  } // #region Grouping integer digits\n  // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n  // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n  // unless the rounded number is greater than 10000:\n  //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n  //   NumberFormat('de').format(1234) //=> \"1.234\"\n\n\n  if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n    var groupSepSymbol = symbols.group;\n    var groups = []; // > There may be two different grouping sizes: The primary grouping size used for the least\n    // > significant integer group, and the secondary grouping size used for more significant groups.\n    // > If a pattern contains multiple grouping separators, the interval between the last one and the\n    // > end of the integer defines the primary grouping size, and the interval between the last two\n    // > defines the secondary grouping size. All others are ignored.\n\n    var integerNumberPattern = decimalNumberPattern.split('.')[0];\n    var patternGroups = integerNumberPattern.split(',');\n    var primaryGroupingSize = 3;\n    var secondaryGroupingSize = 3;\n\n    if (patternGroups.length > 1) {\n      primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n    }\n\n    if (patternGroups.length > 2) {\n      secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n    }\n\n    var i = integer.length - primaryGroupingSize;\n\n    if (i > 0) {\n      // Slice the least significant integer group\n      groups.push(integer.slice(i, i + primaryGroupingSize)); // Then iteratively push the more signicant groups\n      // TODO: handle surrogate pairs in some numbering system digits\n\n      for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n        groups.push(integer.slice(i, i + secondaryGroupingSize));\n      }\n\n      groups.push(integer.slice(0, i + secondaryGroupingSize));\n    } else {\n      groups.push(integer);\n    }\n\n    while (groups.length > 0) {\n      var integerGroup = groups.pop();\n      result.push({\n        type: 'integer',\n        value: integerGroup\n      });\n\n      if (groups.length > 0) {\n        result.push({\n          type: 'group',\n          value: groupSepSymbol\n        });\n      }\n    }\n  } else {\n    result.push({\n      type: 'integer',\n      value: integer\n    });\n  } // #endregion\n\n\n  if (fraction !== undefined) {\n    result.push({\n      type: 'decimal',\n      value: symbols.decimal\n    }, {\n      type: 'fraction',\n      value: fraction\n    });\n  }\n\n  if ((notation === 'scientific' || notation === 'engineering') && isFinite(x)) {\n    result.push({\n      type: 'exponentSeparator',\n      value: symbols.exponential\n    });\n\n    if (exponent < 0) {\n      result.push({\n        type: 'exponentMinusSign',\n        value: symbols.minusSign\n      });\n      exponent = -exponent;\n    }\n\n    var exponentResult = ToRawFixed(exponent, 0, 0);\n    result.push({\n      type: 'exponentInteger',\n      value: exponentResult.formattedString\n    });\n  }\n\n  return result;\n}\n\nfunction getPatternForSign(pattern, sign) {\n  if (pattern.indexOf(';') < 0) {\n    pattern = pattern + \";-\" + pattern;\n  }\n\n  var _a = pattern.split(';'),\n      zeroPattern = _a[0],\n      negativePattern = _a[1];\n\n  switch (sign) {\n    case 0:\n      return zeroPattern;\n\n    case -1:\n      return negativePattern;\n\n    default:\n      return negativePattern.indexOf('-') >= 0 ? negativePattern.replace(/-/g, '+') : \"+\" + zeroPattern;\n  }\n} // Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\n\n\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n  var _a;\n\n  var roundedNumber = numberResult.roundedNumber,\n      sign = numberResult.sign,\n      magnitude = numberResult.magnitude;\n  var magnitudeKey = String(Math.pow(10, magnitude));\n  var defaultNumberingSystem = data.numbers.nu[0];\n  var pattern;\n\n  if (style === 'currency' && currencyDisplay !== 'name') {\n    var byNumberingSystem = data.numbers.currency;\n    var currencyData = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem]; // NOTE: compact notation ignores currencySign!\n\n    var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n\n    if (!compactPluralRules) {\n      return null;\n    }\n\n    pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n  } else {\n    var byNumberingSystem = data.numbers.decimal;\n    var byCompactDisplay = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n\n    if (!compactPlaralRule) {\n      return null;\n    }\n\n    pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n  } // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n  // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n  // > pattern for that sort of object is supplied.\n\n\n  if (pattern === '0') {\n    return null;\n  }\n\n  pattern = getPatternForSign(pattern, sign) // Extract compact literal from the pattern\n  .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}') // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n  .replace(/0+/, '0');\n  return pattern;\n}\n\nfunction selectPlural(pl, x, rules) {\n  return rules[pl.select(x)] || rules.other;\n}","map":{"version":3,"sources":["/Users/alireza/Desktop/Admin Panel/tosanex-admin-panel/src/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/format_to_parts.js"],"names":["ToRawFixed","digitMapping","S_UNICODE_REGEX","CARET_S_UNICODE_REGEX","RegExp","source","S_DOLLAR_UNICODE_REGEX","CLDR_NUMBER_PATTERN","formatToParts","numberResult","data","pl","options","sign","exponent","magnitude","notation","style","numberingSystem","defaultNumberingSystem","numbers","nu","compactNumberPattern","getCompactDisplayPattern","compactDisplay","currencyDisplay","nonNameCurrencyPart","byCurrencyDisplay","currencies","currency","symbol","narrow","numberPattern","decimalData","decimal","getPatternForSign","standard","currencyData","currencySign","percentPattern","percent","decimalNumberPattern","exec","replace","afterCurrency","currencySpacing","afterInsertBetween","test","beforeCurrency","beforeInsertBetween","numberPatternParts","split","numberParts","symbols","_i","numberPatternParts_1","length","part","push","apply","paritionNumberIntoParts","useGrouping","type","value","minusSign","plusSign","percentSign","substring","unitPattern","unitName","currencyNameData","selectPlural","roundedNumber","Math","pow","displayName","unitPatternParts","result","_a","unitPatternParts_1","unit","unitDisplay","unitData","units","simple","_b","numeratorUnit","denominatorUnit","numeratorUnitPattern","perUnitPattern","perUnit","perPattern","compound","per","denominatorPattern","_c","_d","interpolateMatch","n","formattedString","x","isNaN","isFinite","digitReplacementTable","digit","decimalSepIndex","indexOf","integer","fraction","slice","groupSepSymbol","group","groups","integerNumberPattern","patternGroups","primaryGroupingSize","secondaryGroupingSize","i","integerGroup","pop","undefined","exponential","exponentResult","pattern","zeroPattern","negativePattern","magnitudeKey","String","byNumberingSystem","compactPluralRules","short","byCompactDisplay","compactPlaralRule","rules","select","other"],"mappings":"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","sourcesContent":["import { ToRawFixed } from './ToRawFixed';\nimport { digitMapping } from './digit-mapping.generated';\nimport { S_UNICODE_REGEX } from '../regex.generated';\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\" + S_UNICODE_REGEX.source);\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(S_UNICODE_REGEX.source + \"$\");\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n    var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;\n    var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;\n    var defaultNumberingSystem = data.numbers.nu[0];\n    // #region Part 1: partition and interpolate the CLDR number pattern.\n    // ----------------------------------------------------------\n    var compactNumberPattern = null;\n    if (notation === 'compact' && magnitude) {\n        compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n    }\n    // This is used multiple times\n    var nonNameCurrencyPart;\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var byCurrencyDisplay = data.currencies[options.currency];\n        if (byCurrencyDisplay) {\n            switch (options.currencyDisplay) {\n                case 'code':\n                    nonNameCurrencyPart = options.currency;\n                    break;\n                case 'symbol':\n                    nonNameCurrencyPart = byCurrencyDisplay.symbol;\n                    break;\n                default:\n                    nonNameCurrencyPart = byCurrencyDisplay.narrow;\n                    break;\n            }\n        }\n        else {\n            // Fallback for unknown currency\n            nonNameCurrencyPart = options.currency;\n        }\n    }\n    var numberPattern;\n    if (!compactNumberPattern) {\n        // Note: if the style is unit, or is currency and the currency display is name,\n        // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n        if (style === 'decimal' ||\n            style === 'unit' ||\n            (style === 'currency' && options.currencyDisplay === 'name')) {\n            // Shortcut for decimal\n            var decimalData = data.numbers.decimal[numberingSystem] ||\n                data.numbers.decimal[defaultNumberingSystem];\n            numberPattern = getPatternForSign(decimalData.standard, sign);\n        }\n        else if (style === 'currency') {\n            var currencyData = data.numbers.currency[numberingSystem] ||\n                data.numbers.currency[defaultNumberingSystem];\n            // We replace number pattern part with `0` for easier postprocessing.\n            numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n        }\n        else {\n            // percent\n            var percentPattern = data.numbers.percent[numberingSystem] ||\n                data.numbers.percent[defaultNumberingSystem];\n            numberPattern = getPatternForSign(percentPattern, sign);\n        }\n    }\n    else {\n        numberPattern = compactNumberPattern;\n    }\n    // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n    // used to infer decimal group sizes.\n    var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n    // Now we start to substitute patterns\n    // 1. replace strings like `0` and `#,##0.00` with `{0}`\n    // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n    numberPattern = numberPattern\n        .replace(CLDR_NUMBER_PATTERN, '{0}')\n        .replace(/'(.)'/g, '$1');\n    // Handle currency spacing (both compact and non-compact).\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var currencyData = data.numbers.currency[numberingSystem] ||\n            data.numbers.currency[defaultNumberingSystem];\n        // See `currencySpacing` substitution rule in TR-35.\n        // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n        //\n        // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n        // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n        // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n        //\n        // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n        // and number, because `$` does not match \"[:^S:]\".\n        //\n        // Implementation note: here we do the best effort to infer the insertion.\n        // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n        var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n        if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\" + afterCurrency + \"{0}\");\n        }\n        var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n        if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('{0}¤', \"{0}\" + beforeCurrency + \"\\u00A4\");\n        }\n    }\n    // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n    var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n    var numberParts = [];\n    var symbols = data.numbers.symbols[numberingSystem] ||\n        data.numbers.symbols[defaultNumberingSystem];\n    for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n        var part = numberPatternParts_1[_i];\n        if (!part) {\n            continue;\n        }\n        switch (part) {\n            case '{0}': {\n                // We only need to handle scientific and engineering notation here.\n                numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, \n                // If compact number pattern exists, do not insert group separators.\n                !compactNumberPattern && options.useGrouping, decimalNumberPattern));\n                break;\n            }\n            case '-':\n                numberParts.push({ type: 'minusSign', value: symbols.minusSign });\n                break;\n            case '+':\n                numberParts.push({ type: 'plusSign', value: symbols.plusSign });\n                break;\n            case '%':\n                numberParts.push({ type: 'percentSign', value: symbols.percentSign });\n                break;\n            case '¤':\n                // Computed above when handling currency spacing.\n                numberParts.push({ type: 'currency', value: nonNameCurrencyPart });\n                break;\n            default:\n                if (/^\\{c:/.test(part)) {\n                    numberParts.push({\n                        type: 'compact',\n                        value: part.substring(3, part.length - 1),\n                    });\n                }\n                else {\n                    // literal\n                    numberParts.push({ type: 'literal', value: part });\n                }\n                break;\n        }\n    }\n    // #endregion\n    // #region Part 2: interpolate unit pattern if necessary.\n    // ----------------------------------------------\n    switch (style) {\n        case 'currency': {\n            // `currencyDisplay: 'name'` has similar pattern handling as units.\n            if (options.currencyDisplay === 'name') {\n                var unitPattern = (data.numbers.currency[numberingSystem] ||\n                    data.numbers.currency[defaultNumberingSystem]).unitPattern;\n                // Select plural\n                var unitName = void 0;\n                var currencyNameData = data.currencies[options.currency];\n                if (currencyNameData) {\n                    unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n                }\n                else {\n                    // Fallback for unknown currency\n                    unitName = options.currency;\n                }\n                // Do {0} and {1} substitution\n                var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n                var result = [];\n                for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n                    var part = unitPatternParts_1[_a];\n                    switch (part) {\n                        case '{0}':\n                            result.push.apply(result, numberParts);\n                            break;\n                        case '{1}':\n                            result.push({ type: 'currency', value: unitName });\n                            break;\n                        default:\n                            if (part) {\n                                result.push({ type: 'literal', value: part });\n                            }\n                            break;\n                    }\n                }\n                return result;\n            }\n            else {\n                return numberParts;\n            }\n        }\n        case 'unit': {\n            var unit = options.unit, unitDisplay = options.unitDisplay;\n            var unitData = data.units.simple[unit];\n            var unitPattern = void 0;\n            if (unitData) {\n                // Simple unit pattern\n                unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n            }\n            else {\n                // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n                // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n                // Implementation note: we are not following TR-35 here because we need to format to parts!\n                var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];\n                unitData = data.units.simple[numeratorUnit];\n                var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n                var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n                if (perUnitPattern) {\n                    // perUnitPattern exists, combine it with numeratorUnitPattern\n                    unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n                }\n                else {\n                    // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n                    // the denominator pattern in singular form.\n                    var perPattern = data.units.compound.per[unitDisplay];\n                    var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n                    unitPattern = unitPattern = perPattern\n                        .replace('{0}', numeratorUnitPattern)\n                        .replace('{1}', denominatorPattern.replace('{0}', ''));\n                }\n            }\n            var result = [];\n            // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n            for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n                var part = _d[_c];\n                var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n                if (interpolateMatch) {\n                    // Space before \"{0}\"\n                    if (interpolateMatch[1]) {\n                        result.push({ type: 'literal', value: interpolateMatch[1] });\n                    }\n                    // \"{0}\" itself\n                    result.push.apply(result, numberParts);\n                    // Space after \"{0}\"\n                    if (interpolateMatch[2]) {\n                        result.push({ type: 'literal', value: interpolateMatch[2] });\n                    }\n                }\n                else if (part) {\n                    result.push({ type: 'unit', value: part });\n                }\n            }\n            return result;\n        }\n        default:\n            return numberParts;\n    }\n    // #endregion\n}\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, \n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n    var result = [];\n    // eslint-disable-next-line prefer-const\n    var n = numberResult.formattedString, x = numberResult.roundedNumber;\n    if (isNaN(x)) {\n        return [{ type: 'nan', value: n }];\n    }\n    else if (!isFinite(x)) {\n        return [{ type: 'infinity', value: n }];\n    }\n    var digitReplacementTable = digitMapping[numberingSystem];\n    if (digitReplacementTable) {\n        n = n.replace(/\\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });\n    }\n    // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n    // representation of n in the given numbering system.\n    var decimalSepIndex = n.indexOf('.');\n    var integer;\n    var fraction;\n    if (decimalSepIndex > 0) {\n        integer = n.slice(0, decimalSepIndex);\n        fraction = n.slice(decimalSepIndex + 1);\n    }\n    else {\n        integer = n;\n    }\n    // #region Grouping integer digits\n    // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n    // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n    // unless the rounded number is greater than 10000:\n    //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n    //   NumberFormat('de').format(1234) //=> \"1.234\"\n    if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n        var groupSepSymbol = symbols.group;\n        var groups = [];\n        // > There may be two different grouping sizes: The primary grouping size used for the least\n        // > significant integer group, and the secondary grouping size used for more significant groups.\n        // > If a pattern contains multiple grouping separators, the interval between the last one and the\n        // > end of the integer defines the primary grouping size, and the interval between the last two\n        // > defines the secondary grouping size. All others are ignored.\n        var integerNumberPattern = decimalNumberPattern.split('.')[0];\n        var patternGroups = integerNumberPattern.split(',');\n        var primaryGroupingSize = 3;\n        var secondaryGroupingSize = 3;\n        if (patternGroups.length > 1) {\n            primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n        }\n        if (patternGroups.length > 2) {\n            secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n        }\n        var i = integer.length - primaryGroupingSize;\n        if (i > 0) {\n            // Slice the least significant integer group\n            groups.push(integer.slice(i, i + primaryGroupingSize));\n            // Then iteratively push the more signicant groups\n            // TODO: handle surrogate pairs in some numbering system digits\n            for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n                groups.push(integer.slice(i, i + secondaryGroupingSize));\n            }\n            groups.push(integer.slice(0, i + secondaryGroupingSize));\n        }\n        else {\n            groups.push(integer);\n        }\n        while (groups.length > 0) {\n            var integerGroup = groups.pop();\n            result.push({ type: 'integer', value: integerGroup });\n            if (groups.length > 0) {\n                result.push({ type: 'group', value: groupSepSymbol });\n            }\n        }\n    }\n    else {\n        result.push({ type: 'integer', value: integer });\n    }\n    // #endregion\n    if (fraction !== undefined) {\n        result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });\n    }\n    if ((notation === 'scientific' || notation === 'engineering') &&\n        isFinite(x)) {\n        result.push({ type: 'exponentSeparator', value: symbols.exponential });\n        if (exponent < 0) {\n            result.push({ type: 'exponentMinusSign', value: symbols.minusSign });\n            exponent = -exponent;\n        }\n        var exponentResult = ToRawFixed(exponent, 0, 0);\n        result.push({\n            type: 'exponentInteger',\n            value: exponentResult.formattedString,\n        });\n    }\n    return result;\n}\nfunction getPatternForSign(pattern, sign) {\n    if (pattern.indexOf(';') < 0) {\n        pattern = pattern + \";-\" + pattern;\n    }\n    var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];\n    switch (sign) {\n        case 0:\n            return zeroPattern;\n        case -1:\n            return negativePattern;\n        default:\n            return negativePattern.indexOf('-') >= 0\n                ? negativePattern.replace(/-/g, '+')\n                : \"+\" + zeroPattern;\n    }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n    var _a;\n    var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;\n    var magnitudeKey = String(Math.pow(10, magnitude));\n    var defaultNumberingSystem = data.numbers.nu[0];\n    var pattern;\n    if (style === 'currency' && currencyDisplay !== 'name') {\n        var byNumberingSystem = data.numbers.currency;\n        var currencyData = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        // NOTE: compact notation ignores currencySign!\n        var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n        if (!compactPluralRules) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n    }\n    else {\n        var byNumberingSystem = data.numbers.decimal;\n        var byCompactDisplay = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n        if (!compactPlaralRule) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n    }\n    // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n    // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n    // > pattern for that sort of object is supplied.\n    if (pattern === '0') {\n        return null;\n    }\n    pattern = getPatternForSign(pattern, sign)\n        // Extract compact literal from the pattern\n        .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n        // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n        .replace(/0+/, '0');\n    return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n    return rules[pl.select(x)] || rules.other;\n}\n"]},"metadata":{},"sourceType":"module"}