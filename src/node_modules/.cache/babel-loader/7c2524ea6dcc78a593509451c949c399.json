{"ast":null,"code":"/**\n * The abstract operation ComputeExponentForMagnitude computes an exponent by which to scale a\n * number of the given magnitude (power of ten of the most significant digit) according to the\n * locale and the desired notation (scientific, engineering, or compact).\n */\nexport function ComputeExponentForMagnitude(numberFormat, magnitude, _a) {\n  var getInternalSlots = _a.getInternalSlots;\n  var internalSlots = getInternalSlots(numberFormat);\n  var notation = internalSlots.notation,\n      dataLocaleData = internalSlots.dataLocaleData,\n      numberingSystem = internalSlots.numberingSystem;\n\n  switch (notation) {\n    case 'standard':\n      return 0;\n\n    case 'scientific':\n      return magnitude;\n\n    case 'engineering':\n      return Math.floor(magnitude / 3) * 3;\n\n    default:\n      {\n        // Let exponent be an implementation- and locale-dependent (ILD) integer by which to scale a\n        // number of the given magnitude in compact notation for the current locale.\n        var compactDisplay = internalSlots.compactDisplay,\n            style = internalSlots.style,\n            currencyDisplay = internalSlots.currencyDisplay;\n        var thresholdMap = void 0;\n\n        if (style === 'currency' && currencyDisplay !== 'name') {\n          var currency = dataLocaleData.numbers.currency[numberingSystem] || dataLocaleData.numbers.currency[dataLocaleData.numbers.nu[0]];\n          thresholdMap = currency.short;\n        } else {\n          var decimal = dataLocaleData.numbers.decimal[numberingSystem] || dataLocaleData.numbers.decimal[dataLocaleData.numbers.nu[0]];\n          thresholdMap = compactDisplay === 'long' ? decimal.long : decimal.short;\n        }\n\n        if (!thresholdMap) {\n          return 0;\n        }\n\n        var num = String(Math.pow(10, magnitude));\n        var thresholds = Object.keys(thresholdMap); // TODO: this can be pre-processed\n\n        if (num < thresholds[0]) {\n          return 0;\n        }\n\n        if (num > thresholds[thresholds.length - 1]) {\n          return thresholds[thresholds.length - 1].length - 1;\n        }\n\n        var i = thresholds.indexOf(num);\n\n        if (i === -1) {\n          return 0;\n        } // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n        // Special handling if the pattern is precisely `0`.\n\n\n        var magnitudeKey = thresholds[i]; // TODO: do we need to handle plural here?\n\n        var compactPattern = thresholdMap[magnitudeKey].other;\n\n        if (compactPattern === '0') {\n          return 0;\n        } // Example: in zh-TW, `10000000` maps to `0000萬`. So we need to return 8 - 4 = 4 here.\n\n\n        return magnitudeKey.length - thresholdMap[magnitudeKey].other.match(/0+/)[0].length;\n      }\n  }\n}","map":{"version":3,"sources":["/Users/alireza/Desktop/Admin Panel/tosanex-admin-panel/src/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/ComputeExponentForMagnitude.js"],"names":["ComputeExponentForMagnitude","numberFormat","magnitude","_a","getInternalSlots","internalSlots","notation","dataLocaleData","numberingSystem","Math","floor","compactDisplay","style","currencyDisplay","thresholdMap","currency","numbers","nu","short","decimal","long","num","String","pow","thresholds","Object","keys","length","i","indexOf","magnitudeKey","compactPattern","other","match"],"mappings":"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","sourcesContent":["/**\n * The abstract operation ComputeExponentForMagnitude computes an exponent by which to scale a\n * number of the given magnitude (power of ten of the most significant digit) according to the\n * locale and the desired notation (scientific, engineering, or compact).\n */\nexport function ComputeExponentForMagnitude(numberFormat, magnitude, _a) {\n    var getInternalSlots = _a.getInternalSlots;\n    var internalSlots = getInternalSlots(numberFormat);\n    var notation = internalSlots.notation, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;\n    switch (notation) {\n        case 'standard':\n            return 0;\n        case 'scientific':\n            return magnitude;\n        case 'engineering':\n            return Math.floor(magnitude / 3) * 3;\n        default: {\n            // Let exponent be an implementation- and locale-dependent (ILD) integer by which to scale a\n            // number of the given magnitude in compact notation for the current locale.\n            var compactDisplay = internalSlots.compactDisplay, style = internalSlots.style, currencyDisplay = internalSlots.currencyDisplay;\n            var thresholdMap = void 0;\n            if (style === 'currency' && currencyDisplay !== 'name') {\n                var currency = dataLocaleData.numbers.currency[numberingSystem] ||\n                    dataLocaleData.numbers.currency[dataLocaleData.numbers.nu[0]];\n                thresholdMap = currency.short;\n            }\n            else {\n                var decimal = dataLocaleData.numbers.decimal[numberingSystem] ||\n                    dataLocaleData.numbers.decimal[dataLocaleData.numbers.nu[0]];\n                thresholdMap = compactDisplay === 'long' ? decimal.long : decimal.short;\n            }\n            if (!thresholdMap) {\n                return 0;\n            }\n            var num = String(Math.pow(10, magnitude));\n            var thresholds = Object.keys(thresholdMap); // TODO: this can be pre-processed\n            if (num < thresholds[0]) {\n                return 0;\n            }\n            if (num > thresholds[thresholds.length - 1]) {\n                return thresholds[thresholds.length - 1].length - 1;\n            }\n            var i = thresholds.indexOf(num);\n            if (i === -1) {\n                return 0;\n            }\n            // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n            // Special handling if the pattern is precisely `0`.\n            var magnitudeKey = thresholds[i];\n            // TODO: do we need to handle plural here?\n            var compactPattern = thresholdMap[magnitudeKey].other;\n            if (compactPattern === '0') {\n                return 0;\n            }\n            // Example: in zh-TW, `10000000` maps to `0000萬`. So we need to return 8 - 4 = 4 here.\n            return (magnitudeKey.length -\n                thresholdMap[magnitudeKey].other.match(/0+/)[0].length);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}