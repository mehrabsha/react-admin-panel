{"ast":null,"code":"import { repeat, getMagnitude } from '../utils';\nexport function ToRawPrecision(x, minPrecision, maxPrecision) {\n  var p = maxPrecision;\n  var m;\n  var e;\n  var xFinal;\n\n  if (x === 0) {\n    m = repeat('0', p);\n    e = 0;\n    xFinal = 0;\n  } else {\n    var xToString = x.toString(); // If xToString is formatted as scientific notation, the number is either very small or very\n    // large. If the precision of the formatted string is lower that requested max precision, we\n    // should still infer them from the formatted string, otherwise the formatted result might have\n    // precision loss (e.g. 1e41 will not have 0 in every trailing digits).\n\n    var xToStringExponentIndex = xToString.indexOf('e');\n\n    var _a = xToString.split('e'),\n        xToStringMantissa = _a[0],\n        xToStringExponent = _a[1];\n\n    var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');\n\n    if (xToStringExponentIndex >= 0 && xToStringMantissaWithoutDecimalPoint.length <= p) {\n      e = +xToStringExponent;\n      m = xToStringMantissaWithoutDecimalPoint + repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);\n      xFinal = x;\n    } else {\n      e = getMagnitude(x);\n      var decimalPlaceOffset = e - p + 1; // n is the integer containing the required precision digits. To derive the formatted string,\n      // we will adjust its decimal place in the logic below.\n\n      var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset)); // The rounding caused the change of magnitude, so we should increment `e` by 1.\n\n      if (adjustDecimalPlace(n, p - 1) >= 10) {\n        e = e + 1; // Divide n by 10 to swallow one precision.\n\n        n = Math.floor(n / 10);\n      }\n\n      m = n.toString(); // Equivalent of n * 10 ** (e - p + 1)\n\n      xFinal = adjustDecimalPlace(n, p - 1 - e);\n    }\n  }\n\n  var int;\n\n  if (e >= p - 1) {\n    m = m + repeat('0', e - p + 1);\n    int = e + 1;\n  } else if (e >= 0) {\n    m = m.slice(0, e + 1) + \".\" + m.slice(e + 1);\n    int = e + 1;\n  } else {\n    m = \"0.\" + repeat('0', -e - 1) + m;\n    int = 1;\n  }\n\n  if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {\n    var cut = maxPrecision - minPrecision;\n\n    while (cut > 0 && m[m.length - 1] === '0') {\n      m = m.slice(0, -1);\n      cut--;\n    }\n\n    if (m[m.length - 1] === '.') {\n      m = m.slice(0, -1);\n    }\n  }\n\n  return {\n    formattedString: m,\n    roundedNumber: xFinal,\n    integerDigitsCount: int\n  }; // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.\n\n  function adjustDecimalPlace(x, magnitude) {\n    return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);\n  }\n}","map":{"version":3,"sources":["/Users/alireza/Desktop/Admin Panel/tosanex-admin-panel/src/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/ToRawPrecision.js"],"names":["repeat","getMagnitude","ToRawPrecision","x","minPrecision","maxPrecision","p","m","e","xFinal","xToString","toString","xToStringExponentIndex","indexOf","_a","split","xToStringMantissa","xToStringExponent","xToStringMantissaWithoutDecimalPoint","replace","length","decimalPlaceOffset","n","Math","round","adjustDecimalPlace","floor","int","slice","cut","formattedString","roundedNumber","integerDigitsCount","magnitude","pow"],"mappings":"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","sourcesContent":["import { repeat, getMagnitude } from '../utils';\nexport function ToRawPrecision(x, minPrecision, maxPrecision) {\n    var p = maxPrecision;\n    var m;\n    var e;\n    var xFinal;\n    if (x === 0) {\n        m = repeat('0', p);\n        e = 0;\n        xFinal = 0;\n    }\n    else {\n        var xToString = x.toString();\n        // If xToString is formatted as scientific notation, the number is either very small or very\n        // large. If the precision of the formatted string is lower that requested max precision, we\n        // should still infer them from the formatted string, otherwise the formatted result might have\n        // precision loss (e.g. 1e41 will not have 0 in every trailing digits).\n        var xToStringExponentIndex = xToString.indexOf('e');\n        var _a = xToString.split('e'), xToStringMantissa = _a[0], xToStringExponent = _a[1];\n        var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');\n        if (xToStringExponentIndex >= 0 &&\n            xToStringMantissaWithoutDecimalPoint.length <= p) {\n            e = +xToStringExponent;\n            m =\n                xToStringMantissaWithoutDecimalPoint +\n                    repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);\n            xFinal = x;\n        }\n        else {\n            e = getMagnitude(x);\n            var decimalPlaceOffset = e - p + 1;\n            // n is the integer containing the required precision digits. To derive the formatted string,\n            // we will adjust its decimal place in the logic below.\n            var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));\n            // The rounding caused the change of magnitude, so we should increment `e` by 1.\n            if (adjustDecimalPlace(n, p - 1) >= 10) {\n                e = e + 1;\n                // Divide n by 10 to swallow one precision.\n                n = Math.floor(n / 10);\n            }\n            m = n.toString();\n            // Equivalent of n * 10 ** (e - p + 1)\n            xFinal = adjustDecimalPlace(n, p - 1 - e);\n        }\n    }\n    var int;\n    if (e >= p - 1) {\n        m = m + repeat('0', e - p + 1);\n        int = e + 1;\n    }\n    else if (e >= 0) {\n        m = m.slice(0, e + 1) + \".\" + m.slice(e + 1);\n        int = e + 1;\n    }\n    else {\n        m = \"0.\" + repeat('0', -e - 1) + m;\n        int = 1;\n    }\n    if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {\n        var cut = maxPrecision - minPrecision;\n        while (cut > 0 && m[m.length - 1] === '0') {\n            m = m.slice(0, -1);\n            cut--;\n        }\n        if (m[m.length - 1] === '.') {\n            m = m.slice(0, -1);\n        }\n    }\n    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };\n    // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.\n    function adjustDecimalPlace(x, magnitude) {\n        return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}