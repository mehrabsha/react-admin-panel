{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { Parser } from './parser';\nimport { isDateElement, isDateTimeSkeleton, isNumberElement, isNumberSkeleton, isPluralElement, isSelectElement, isTagElement, isTimeElement } from './types';\n\nfunction pruneLocation(els) {\n  els.forEach(function (el) {\n    delete el.location;\n\n    if (isSelectElement(el) || isPluralElement(el)) {\n      for (var k in el.options) {\n        delete el.options[k].location;\n        pruneLocation(el.options[k].value);\n      }\n    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {\n      delete el.style.location;\n    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {\n      delete el.style.location;\n    } else if (isTagElement(el)) {\n      pruneLocation(el.children);\n    }\n  });\n}\n\nexport function parse(message, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  opts = __assign({\n    shouldParseSkeletons: true,\n    requiresOtherClause: true\n  }, opts);\n  var result = new Parser(message, opts).parse();\n\n  if (result.err) {\n    var error = SyntaxError(ErrorKind[result.err.kind]); // @ts-expect-error Assign to error object\n\n    error.location = result.err.location; // @ts-expect-error Assign to error object\n\n    error.originalMessage = result.err.message;\n    throw error;\n  }\n\n  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {\n    pruneLocation(result.val);\n  }\n\n  return result.val;\n}\nexport * from './types';","map":{"version":3,"sources":["/Users/alireza/Desktop/Admin Panel/tosanex-admin-panel/src/node_modules/@formatjs/icu-messageformat-parser/lib/index.js"],"names":["__assign","ErrorKind","Parser","isDateElement","isDateTimeSkeleton","isNumberElement","isNumberSkeleton","isPluralElement","isSelectElement","isTagElement","isTimeElement","pruneLocation","els","forEach","el","location","k","options","value","style","children","parse","message","opts","shouldParseSkeletons","requiresOtherClause","result","err","error","SyntaxError","kind","originalMessage","captureLocation","val"],"mappings":"AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA,SAASC,SAAT,QAA0B,SAA1B;AACA,SAASC,MAAT,QAAuB,UAAvB;AACA,SAASC,aAAT,EAAwBC,kBAAxB,EAA4CC,eAA5C,EAA6DC,gBAA7D,EAA+EC,eAA/E,EAAgGC,eAAhG,EAAiHC,YAAjH,EAA+HC,aAA/H,QAAqJ,SAArJ;;AACA,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;AACxBA,EAAAA,GAAG,CAACC,OAAJ,CAAY,UAAUC,EAAV,EAAc;AACtB,WAAOA,EAAE,CAACC,QAAV;;AACA,QAAIP,eAAe,CAACM,EAAD,CAAf,IAAuBP,eAAe,CAACO,EAAD,CAA1C,EAAgD;AAC5C,WAAK,IAAIE,CAAT,IAAcF,EAAE,CAACG,OAAjB,EAA0B;AACtB,eAAOH,EAAE,CAACG,OAAH,CAAWD,CAAX,EAAcD,QAArB;AACAJ,QAAAA,aAAa,CAACG,EAAE,CAACG,OAAH,CAAWD,CAAX,EAAcE,KAAf,CAAb;AACH;AACJ,KALD,MAMK,IAAIb,eAAe,CAACS,EAAD,CAAf,IAAuBR,gBAAgB,CAACQ,EAAE,CAACK,KAAJ,CAA3C,EAAuD;AACxD,aAAOL,EAAE,CAACK,KAAH,CAASJ,QAAhB;AACH,KAFI,MAGA,IAAI,CAACZ,aAAa,CAACW,EAAD,CAAb,IAAqBJ,aAAa,CAACI,EAAD,CAAnC,KACLV,kBAAkB,CAACU,EAAE,CAACK,KAAJ,CADjB,EAC6B;AAC9B,aAAOL,EAAE,CAACK,KAAH,CAASJ,QAAhB;AACH,KAHI,MAIA,IAAIN,YAAY,CAACK,EAAD,CAAhB,EAAsB;AACvBH,MAAAA,aAAa,CAACG,EAAE,CAACM,QAAJ,CAAb;AACH;AACJ,GAlBD;AAmBH;;AACD,OAAO,SAASC,KAAT,CAAeC,OAAf,EAAwBC,IAAxB,EAA8B;AACjC,MAAIA,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAEA,IAAAA,IAAI,GAAG,EAAP;AAAY;;AACnCA,EAAAA,IAAI,GAAGvB,QAAQ,CAAC;AAAEwB,IAAAA,oBAAoB,EAAE,IAAxB;AAA8BC,IAAAA,mBAAmB,EAAE;AAAnD,GAAD,EAA4DF,IAA5D,CAAf;AACA,MAAIG,MAAM,GAAG,IAAIxB,MAAJ,CAAWoB,OAAX,EAAoBC,IAApB,EAA0BF,KAA1B,EAAb;;AACA,MAAIK,MAAM,CAACC,GAAX,EAAgB;AACZ,QAAIC,KAAK,GAAGC,WAAW,CAAC5B,SAAS,CAACyB,MAAM,CAACC,GAAP,CAAWG,IAAZ,CAAV,CAAvB,CADY,CAEZ;;AACAF,IAAAA,KAAK,CAACb,QAAN,GAAiBW,MAAM,CAACC,GAAP,CAAWZ,QAA5B,CAHY,CAIZ;;AACAa,IAAAA,KAAK,CAACG,eAAN,GAAwBL,MAAM,CAACC,GAAP,CAAWL,OAAnC;AACA,UAAMM,KAAN;AACH;;AACD,MAAI,EAAEL,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACS,eAAnD,CAAJ,EAAyE;AACrErB,IAAAA,aAAa,CAACe,MAAM,CAACO,GAAR,CAAb;AACH;;AACD,SAAOP,MAAM,CAACO,GAAd;AACH;AACD,cAAc,SAAd","sourcesContent":["import { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { Parser } from './parser';\nimport { isDateElement, isDateTimeSkeleton, isNumberElement, isNumberSkeleton, isPluralElement, isSelectElement, isTagElement, isTimeElement, } from './types';\nfunction pruneLocation(els) {\n    els.forEach(function (el) {\n        delete el.location;\n        if (isSelectElement(el) || isPluralElement(el)) {\n            for (var k in el.options) {\n                delete el.options[k].location;\n                pruneLocation(el.options[k].value);\n            }\n        }\n        else if (isNumberElement(el) && isNumberSkeleton(el.style)) {\n            delete el.style.location;\n        }\n        else if ((isDateElement(el) || isTimeElement(el)) &&\n            isDateTimeSkeleton(el.style)) {\n            delete el.style.location;\n        }\n        else if (isTagElement(el)) {\n            pruneLocation(el.children);\n        }\n    });\n}\nexport function parse(message, opts) {\n    if (opts === void 0) { opts = {}; }\n    opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);\n    var result = new Parser(message, opts).parse();\n    if (result.err) {\n        var error = SyntaxError(ErrorKind[result.err.kind]);\n        // @ts-expect-error Assign to error object\n        error.location = result.err.location;\n        // @ts-expect-error Assign to error object\n        error.originalMessage = result.err.message;\n        throw error;\n    }\n    if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {\n        pruneLocation(result.val);\n    }\n    return result.val;\n}\nexport * from './types';\n"]},"metadata":{},"sourceType":"module"}